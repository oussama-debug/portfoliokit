import { createClient, type SupabaseClient } from "@supabase/supabase-js";
import { NotFoundError, InternalError } from "@/error.js";
import type { {{entityName}}Repository } from "../repository.js";
import { {{entityName}} } from "../model.js";

export class Supabase{{entityName}}Repository implements {{entityName}}Repository {
  private readonly _client: SupabaseClient;

  constructor(supabaseUrl: string, supabaseKey: string) {
    this._client = createClient(supabaseUrl, supabaseKey);
  }

  async create(name: string): Promise<{{entityName}}> {
    const { data, error } = await this._client
      .from("{{tableName}}")
      .insert({ name })
      .select()
      .single();

    if (error) {
      throw new InternalError(`Failed to create {{moduleName}}: ${error.message}`);
    }

    return new {{entityName}}(
      data.id,
      data.name,
      new Date(data.created_at)
    );
  }

  async findById(id: string): Promise<{{entityName}} | null> {
    const { data, error } = await this._client
      .from("{{tableName}}")
      .select("*")
      .eq("id", id)
      .single();

    if (error) {
      if (error.code === "PGRST116") return null;
      throw new InternalError(`Failed to fetch {{moduleName}}: ${error.message}`);
    }

    return new {{entityName}}(
      data.id,
      data.name,
      new Date(data.created_at)
    );
  }

  async findAll(): Promise<{{entityName}}[]> {
    const { data, error } = await this._client
      .from("{{tableName}}")
      .select("*")
      .order("created_at", { ascending: false });

    if (error) {
      throw new InternalError(`Failed to fetch {{moduleName}}: ${error.message}`);
    }

    return data.map(
      (item) =>
        new {{entityName}}(
          item.id,
          item.name,
          new Date(item.created_at)
        )
    );
  }

  async update(id: string, data: { name?: string }): Promise<{{entityName}}> {
    const updateData: any = {};
    if (data.name) updateData.name = data.name;

    const { data: result, error } = await this._client
      .from("{{tableName}}")
      .update(updateData)
      .eq("id", id)
      .select()
      .single();

    if (error) {
      throw new InternalError(`Failed to update {{moduleName}}: ${error.message}`);
    }

    if (!result) {
      throw new NotFoundError("{{entityName}} not found");
    }

    return new {{entityName}}(
      result.id,
      result.name,
      new Date(result.created_at)
    );
  }

  async delete(id: string): Promise<void> {
    const { error } = await this._client
      .from("{{tableName}}")
      .delete()
      .eq("id", id);

    if (error) {
      throw new InternalError(`Failed to delete {{moduleName}}: ${error.message}`);
    }
  }
}
